spending validator

struct Datum {
    adaAmount: Int
    lcAmount: Int

    func get_ratio(self) -> Int {
        self.adaAmount / self.lcAmount
    }
}

enum Redeemer {
    AddAda
    Mint
    Burn { 
        pkhBA: ByteArray 
    }
}

const minAda : Int = 2000000
const minAdaVal: Value = Value::lovelace(minAda)

// Define thread token value
const TT_MPH: ByteArray = #ac8e811df3974e849578b214db9e87ccba6d332ec289a0fd9084dba8
const ttMph: MintingPolicyHash = MintingPolicyHash::new(TT_MPH)
const ttAssetclass: AssetClass = AssetClass::new(
        ttMph, 
        "Thread Token Littercoin".encode_utf8()
    )
const ttVal : Value = Value::new(ttAssetclass, 1)

// Define the mph of the littercoin minting policy
const LC_MPH: ByteArray = #ac8e811df3974e849578b214db9e87ccba6d332ec289a0fd9084dba8
const lcMph: MintingPolicyHash = MintingPolicyHash::new(LC_MPH)
const lcAssetClass: AssetClass = AssetClass::new(
        lcMph, 
        "Littercoin".encode_utf8()
    )

// Define the pkh of the owner
const OWNER_PKH: ByteArray = #b9abcf6867519e28042048aa11207214a52e6d5d3288b752d1c27682 
const ownerPkh: PubKeyHash = PubKeyHash::new(OWNER_PKH)

// Define the merchant token
const MERCHANT_MPH: ByteArray = #e57b84e97afe75117f906e57e66ca0718e25c9db3c4076f2bf78555b
const merchMph: MintingPolicyHash = MintingPolicyHash::new(MERCHANT_MPH)
const merchAssetclass: AssetClass = AssetClass::new(
        merchMph, 
        "Merchant Token Littercoin".encode_utf8()
    )
const merchVal: Value = Value::new(merchAssetclass, 1)

func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool {
    
    // Get hash of this validator
    vHash : ValidatorHash = ctx.get_current_validator_hash();
    tx : Tx = ctx.tx;
    txOutput : []TxOutput = tx.outputs_locked_by(vHash);

    redeemer.switch {
        AddAda => {
            txOutput.get(0).datum.switch {
                dat: Inline => { 
                    outDat: Datum = Datum::from_data(dat.data);
                    addAdaDatumAmt: Int = outDat.adaAmount - datum.adaAmount;
                    adaVal: Value = Value::lovelace(outDat.adaAmount);

                    // Verify that the total Ada amount from the datum and
                    // the thread token is the same as the output value
                    // locked at the validator address                   
                    (tx.value_locked_by(vHash) == (ttVal + adaVal)).trace("LCV1: ") &&
                    (addAdaDatumAmt >= minAda).trace("LCV2: ")
                },
                else => false.trace("LCV3: ")
            }

        },
        Mint => {
            txOutput.get(0).datum.switch {
                dat: Inline => { 
                    outDat: Datum = Datum::from_data(dat.data);
                    adaDatumAmt: Int = outDat.adaAmount - datum.adaAmount;
                    adaVal: Value = Value::lovelace(outDat.adaAmount);
                    lcDatumAmt: Int = outDat.lcAmount - datum.lcAmount;
                    lcMintVal: Value = Value::new(lcAssetClass, lcDatumAmt);
        
                    // Verify that the total Ada amount from the datum and
                    // the thread token is the same as the output value
                    // locked at the validator address.  Also check the tx 
                    // is signed by the owner pkh                   
                    (adaDatumAmt == 0).trace("LCV4: ") && 
                    (tx.value_locked_by(vHash) == (ttVal + adaVal)).trace("LCV5: ") &&
                    tx.minted.contains(lcMintVal).trace("LCV6: ") && 
                    tx.is_signed_by(ownerPkh).trace("LCV7: ") &&  
                    (0 < lcDatumAmt && lcDatumAmt < outDat.adaAmount).trace("LCV8: ") 
                },
                else => false.trace("LCV9: " )
            }
        },
        red: Burn => {    
           txOutput.get(0).datum.switch {
                dat: Inline => { 
                    outDat: Datum = Datum::from_data(dat.data);
                    adaDatumAmt: Int = datum.adaAmount - outDat.adaAmount;
                    adaVal: Value = Value::lovelace(outDat.adaAmount);
                    lcDatumAmt: Int = datum.lcAmount - outDat.lcAmount;
                    lcBurnVal: Value = Value::new(lcAssetClass, lcDatumAmt) * (-1);
                    ratio: Int = datum.get_ratio();
                    adaWithdraw : Int = lcDatumAmt * ratio;
                    adaWithdrawVal: Value = Value::lovelace(adaWithdraw);
                    merchPkh: PubKeyHash = PubKeyHash::new(red.pkhBA);
                    merchOutTxs : []TxOutput = tx.outputs_sent_to(merchPkh);
                    
                    // Verify that the amount of littercoin burned is the actual amount
                    // reduced by in the datum.   Also check that the Ada withdraw
                    // is equal to the amount of Ada remanining in the datum output.
                    // Finally confirm that thread token is sent to back to the validator
                    // with correct Ada amount                   
                    (adaDatumAmt == adaWithdraw).trace("LCV10: ") &&
                    (tx.value_locked_by(vHash) == (ttVal + adaVal)).trace("LCV11: ") &&
                    tx.minted.contains(lcBurnVal).trace("LCV12: ") &&
                    merchOutTxs.get(1).value.contains(adaWithdrawVal).trace("LCV13: ") &&
                    merchOutTxs.get(2).value.contains(minAdaVal + merchVal).trace("LCV14: ") 
                },
                else => false.trace("LCV15: ")
            }
        }
    }
}

const LC_DATUM = Datum {
    lcAmount : 0,
    adaAmount : 0
}

const VAL_ADD_ADA_REDEEMER = Redeemer::AddAda
const VAL_MINT_REDEEMER = Redeemer::Mint
const VAL_BURN_REDEEMER = Redeemer::Burn{#1a2b3c}

